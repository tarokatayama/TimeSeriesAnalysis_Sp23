frequency=12)
View(ts_electricity_price)
ts_natural_gas<- ts(net_generation_processed[],
start = c(year(net_generation_processed[1]), month(net_generation_processed[1])),
frequency = 12)
ts_natural_gas<- ts(net_generation_processed,
start = c(year(net_generation_processed[,1]), month(net_generation_processed[,1])),
frequency = 12)
View(ts_natural_gas)
ts_natural_gas<- ts(net_generation_processed[,2],
start = c(year(net_generation_processed[,1]), month(net_generation_processed[,1])),
frequency = 12)
View(net_generation_processed)
ts_natural_gas<- ts(net_generation_processed[,2],
start = c(year(net_generation_processed$Month[1]), month(net_generation_processed$Month[1])),
frequency = 12)
View(net_generation_processed)
ts_plot<- ggplot(net_generation_processed, aes(x=Month, y= naturalgas)) +
geom_line()
plot(ts_plot)
ts_plot<- ggplot(net_generation_processed, aes(x=Month, y= naturalgas)) +
labs(x="Year")+
geom_line()
plot(ts_plot)
View(net_generation)
ts_plot<- ggplot(net_generation_processed, aes(x=Month, y= naturalgas)) +
labs(x="Year", y="Natural Gas (Thousand Megawatt Hours")+
geom_line()
plot(ts_plot)
ts_plot<- ggplot(net_generation_processed, aes(x=Month, y= naturalgas)) +
labs(x="Year", y="Natural Gas (Thousand Megawatt Hours)")+
geom_line()
plot(ts_plot)
par(mfrow=c(1,2))
par(mfrow=c(1,2))
ACF_Plot <- Acf(net_generation_processed$naturalgas, lag = 40, plot = TRUE)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40)
Acf(ts_natural_gas[,1], lag= 40)
Acf(ts_natural_gas, lag= 40)
par(mfrow=c(1,2))
ACF_Plot <- Acf(net_generation_processed$naturalgas, lag = 40, main = "ACF", plot = TRUE)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40)
par(mfrow=c(1,2))
ACF_Plot <- Acf(net_generation_processed$naturalgas, lag = 40, main = "ACF", plot = TRUE)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40, main= "PCF")
par(mfrow=c(1,2))
ACF_Plot <- Acf(net_generation_processed$naturalgas, lag = 40, main = "ACF", plot = TRUE)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40, main= "PACF")
decompose(ts_natural_gas, "additive")
decompose_natural_gas<- decompose(ts_natural_gas, "additive")
View(decompose_natural_gas)
plot(decompose_natural_gas)
deseasonal_natural_gas<- seasadj(ts_natural_gas)
plot(deseasonal_natural_gas)
deseasonal_natural_gas<- seasadj(decompose_natural_gas)
plot(deseasonal_natural_gas)
par(mfrow=c(1,1))
plot(deseasonal_natural_gas)
Acf(deseasonal_natural_gas, lag = 40)
par(mfrow=c(1,2))
Acf(deseasonal_natural_gas, lag = 40)
Pacf(deseasonal_natural_gas, lag = 40)
plot(deseasonal_natural_gas)
plot(deseasonal_natural_gas)
plot(decompose_natural_gas)
plot(deseasonal_natural_gas)
par(mfrow=c(1,2))
Acf(deseasonal_natural_gas, lag = 40)
Pacf(deseasonal_natural_gas, lag = 40)
par(mfrow=c(1,1))
ACF_Plot <- Acf(net_generation_processed$naturalgas, lag = 40, main = "ACF", plot = TRUE)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40, main= "PACF")
Pacf(deseasonal_natural_gas, lag = 40)
adftest<- adf.test(deseasonal_natural_gas, alternative = "stationary")
View(adftest)
print(adftest)
mannkendalltest<- mannkendalltest(deseasonal_natural_gas)
mannkendalltest<- MannKendall(deseasonal_natural_gas)
print(summary(mannkendalltest))
ndiff<- ndiffs(deseasonal_natural_gas)
?Arima()
ARIMA_Manual<- Arima(deseasonal_natural_gas, order = c(2,1,0), include.mean = TRUE)
?cat
cat(ARIMA_Manual)
View(ARIMA_Manual)
cat(ARIMA_Manual$coef)
ARIMA_Manual$
checkresiduals(ARIMA_Manual)
plot(ARIMA_Manual$residuals)
Acf(ARIMA_Manual$residuals)
checkresiduals(ARIMA_Manual, lag=40)
Acf(ARIMA_Manual$residuals,lag=40)
Pacf(ARIMA_Manual$residuals, lag=40)
checkresiduals(ARIMA_Manual, lag=40)
?checkresiduals
checkresiduals(ARIMA_Manual, lag=40)
ARIMA_Manual<- Arima(deseasonal_natural_gas, order = c(2,1,0), include.drift = TRUE)
cat(ARIMA_Manual$coef)
plot(ARIMA_Manual$residuals)
Acf(ARIMA_Manual$residuals,lag=40)
Pacf(ARIMA_Manual$residuals, lag=40)
checkresiduals(ARIMA_Manual, lag=40)
plot(ts_plot)
par(mfrow=c(1,2))
ACF_Plot <- Acf(net_generation_processed$naturalgas, lag = 40, main = "ACF", plot = TRUE)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40, main= "PACF")
adftest2<- adf.test(ts_natural_gas, alternative = "stationary")
print(adftest2)
mannkendalltest2<- MannKendall(ts_natural_gas)
print(summary(mannkendalltest2))
ndiff2<- ndiffs(ts_natural_gas)
SARIMA_Manual<- Arima(ts_natural_gas, order = c(2,1,0), seasonal = c(0,1,1), include.drift = FALSE)
print(SARIMA_Manual)
cat(SARIMA_Manual$coef)
plot(SARIMA_Manual$residuals)
Acf(SARIMA_Manual$residuals,lag=40)
Pacf(SARIMA_Manual$residuals, lag=40)
checkresiduals(SARIMA_Manual, lag=40)
checkresiduals(SARIMA_Manual, lag=40)
checkresiduals(ARIMA_Manual, lag=40)
ARIMA_autofit <- auto.arima(deseasonal_natural_gas, max.D = 0, max.P = 0, max.Q = 0)
print(ARIMA_autofit)
SARIMA_autofit <- auto.arima(ts_natural_gas)
print(SARIMA_autofit)
adftest<- adf.test(deseasonal_natural_gas, alternative = "stationary")
print(adftest)
mannkendalltest<- MannKendall(deseasonal_natural_gas)
print(summary(mannkendalltest))
print(adftest2)
ndiff<- ndiffs(deseasonal_natural_gas)
seasonalmannkendalltest<- SeasonalMannKendall(ts_natural_gas)
print(seasonalmannkendalltest)
par(mfrow=c(1,2))
Acf(deseasonal_natural_gas, lag = 40)
Pacf(deseasonal_natural_gas, lag = 40)
ARIMA_Manual<- Arima(deseasonal_natural_gas, order = c(2,1,0), include.drift = TRUE)
cat(ARIMA_Manual$coef)
Acf(SARIMA_Manual$residuals,lag=40)
Pacf(SARIMA_Manual$residuals, lag=40)
cat("Number of seasonal differencing needed: ",ndiff)
diff_deseas_natural_gas<- diff(deseasonal_natural_gas, lag = 1, differences = 1)
Acf(diff_deseas_natural_gas, lag=40)
Pacf(diff_deseas_natural_gas, lag=40)
# Find out how many time we need to difference
ns_diff <- nsdiffs(ts_electricity_price[,"Residential"])
cat("Number of seasonal differencing needed: ",ns_diff)
#Lets difference the series once at lag 12 to remove the seasonal trend.
residential_price_seas_diff <- diff(ts_electricity_price[,"Residential"],lag=12, differences=1)
residential_price_trend_diff <- diff(ts_electricity_price[,"Residential"],lag =1, differences=1) #diff done on orig series
residential_price_both_diff <- diff(residential_price_trend_diff,lag =12, differences=1)
#Check autocorrelation plots for differenced series
#Comparing ACFs
par(mfrow=c(1,4))
Acf(ts_electricity_price[,"Residential"],lag.max=40,main="Residential",ylim=c(-1,1))
Acf(residential_price_seas_diff,lag.max=60,main="Seasonal-Differenced Residential",ylim=c(-1,1))
Acf(residential_price_trend_diff,lag.max=60,main="Trend-Differenced Residential",ylim=c(-1,1))
par(mfrow=c(1,1))
Acf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
#Comparing PACFs
par(mfrow=c(1,4))
Pacf(ts_electricity_price[,"Residential"],lag.max=40,main="Residential",ylim=c(-1,1))
Pacf(residential_price_seas_diff,lag.max=60,main="Seasonal-Differenced Residential",ylim=c(-1,1))
Pacf(residential_price_trend_diff,lag.max=60,main="Trend-Differenced Residential",ylim=c(-1,1))
Pacf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
#Plot ACF and PACF for twice-differenced series - Steps 3 (order of non-seasonal) and 5 ) order of seasonal
par(mfrow=c(1,2))
Acf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
Pacf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
cat("Number of seasonal differencing needed: ",ndiff2)
nsdiff<- nsdiffs(ts_natural_gas)
cat("Number of seasonal differencing needed: ",nsdiff)
plot(ts_plot)
par(mfrow=c(1,2))
ACF_Plot <- Acf(net_generation_processed$naturalgas, lag = 40, main = "ACF", plot = TRUE)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40, main= "PACF")
#Difference the series once at lag 12 to remove the seasonal trend.
seas_diff <- diff(ts_natural_gas,lag=12, differences=1)
Acf(seas_diff, lag=40)
Pacf(seas_diff, lag=40)
# Find out how many time we need to difference
ns_diff <- nsdiffs(ts_electricity_price[,"Residential"])
cat("Number of seasonal differencing needed: ",ns_diff)
#Lets difference the series once at lag 12 to remove the seasonal trend.
residential_price_seas_diff <- diff(ts_electricity_price[,"Residential"],lag=12, differences=1)
residential_price_trend_diff <- diff(ts_electricity_price[,"Residential"],lag =1, differences=1) #diff done on orig series
residential_price_both_diff <- diff(residential_price_trend_diff,lag =12, differences=1)
#Check autocorrelation plots for differenced series
#Comparing ACFs
par(mfrow=c(1,4))
Acf(ts_electricity_price[,"Residential"],lag.max=40,main="Residential",ylim=c(-1,1))
Acf(residential_price_seas_diff,lag.max=60,main="Seasonal-Differenced Residential",ylim=c(-1,1))
Acf(residential_price_trend_diff,lag.max=60,main="Trend-Differenced Residential",ylim=c(-1,1))
par(mfrow=c(1,1))
Acf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
#Comparing PACFs
par(mfrow=c(1,4))
Pacf(ts_electricity_price[,"Residential"],lag.max=40,main="Residential",ylim=c(-1,1))
Pacf(residential_price_seas_diff,lag.max=60,main="Seasonal-Differenced Residential",ylim=c(-1,1))
Pacf(residential_price_trend_diff,lag.max=60,main="Trend-Differenced Residential",ylim=c(-1,1))
Pacf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
#Plot ACF and PACF for twice-differenced series - Steps 3 (order of non-seasonal) and 5 ) order of seasonal
par(mfrow=c(1,2))
Acf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
Pacf(residential_price_both_diff,lag.max=60,main="Twice-Differenced Residential",ylim=c(-1,1))
Acf(seas_diff, lag=40)
Pacf(seas_diff, lag=40)
adftest2<- adf.test(ts_natural_gas, alternative = "stationary")
print(adftest2)
#seasonalmannkendalltest<- SeasonalMannKendall(ts_natural_gas)
#print(seasonalmannkendalltest)
ndiff2<- ndiffs(ts_natural_gas)
cat("Number of seasonal differencing needed: ",ndiff2)
#seasonalmannkendalltest<- SeasonalMannKendall(ts_natural_gas)
#print(seasonalmannkendalltest)
ndiff2<- ndiffs(ts_natural_gas)
cat("Number of seasonal differencing needed: ",ndiff2)
SARIMA_Manual<- Arima(ts_natural_gas, order = c(1,1,0), seasonal = c(0,1,1), include.drift = FALSE)
cat(SARIMA_Manual$coef)
ARIMA_Manual<- Arima(deseasonal_natural_gas, order = c(1,1,1), include.drift = TRUE)
cat(ARIMA_Manual$coef)
plot(SARIMA_Manual$residuals)
Acf(SARIMA_Manual$residuals,lag=40)
Pacf(SARIMA_Manual$residuals, lag=40)
checkresiduals(SARIMA_Manual, lag=40)
Acf(SARIMA_Manual$residuals,lag=40)
Pacf(SARIMA_Manual$residuals, lag=40)
plot(ARIMA_Manual$residuals)
Acf(ARIMA_Manual$residuals,lag=40)
Pacf(ARIMA_Manual$residuals, lag=40)
checkresiduals(ARIMA_Manual, lag=40)
net_generation<- read.csv("../Data/Net_generation_United_States_all_sectors_monthly.csv", header= TRUE,
stringsAsFactors = TRUE, skip = 4)
Pacf(deseasonal_natural_gas, lag = 40)
Acf(deseasonal_natural_gas, lag = 40)
PACF_Plot <- Pacf(net_generation_processed$naturalgas, lag = 40, main= "PACF")
Acf(diff_deseas_natural_gas, lag=40)
Pacf(diff_deseas_natural_gas, lag=40)
Acf(diff_deseas_natural_gas, lag=40)
Pacf(diff_deseas_natural_gas, lag=40)
Acf(seas_diff, lag=40)
Pacf(seas_diff, lag=40)
ARIMA_autofit <- auto.arima(deseasonal_natural_gas, max.D = 0, max.P = 0, max.Q = 0)
print(ARIMA_autofit)
SARIMA_autofit <- auto.arima(ts_natural_gas)
print(SARIMA_autofit)
knitr::opts_chunk$set(echo = TRUE,tidy.opts=list(width.cutoff=80), tidy=FALSE)
library(lubridate)
library(ggplot2)
library(forecast)
#library(Kendall)
library(tseries)
#library(outliers)
library(tidyverse)
library(smooth)
#New package for M9 to assist with tables
#install.packages("kableExtra")
library(kableExtra)
#Importing time series data from text file#
electricity_price <- read.csv(
file="./Data/Average_retail_price_of_electricity_United_States_monthly.csv",
header=TRUE,
skip=4)
#Inspect data
head(electricity_price)
nvar <- ncol(electricity_price) - 1
nobs <- nrow(electricity_price)
#Preparing the data - create date object and rename columns
electricity_price_processed <-
electricity_price %>%
mutate( Month = my(Month) ) %>%
rename( All.sectors = all.sectors.cents.per.kilowatthour ) %>%
rename( Residential = residential.cents.per.kilowatthour ) %>%
rename( Commercial = commercial.cents.per.kilowatthour ) %>%
rename( Industrial = industrial.cents.per.kilowatthour ) %>%
arrange( Month )
#head(electricity_price_processed)
summary(electricity_price_processed)
#No NAs so we don't need to worry about missing values
#Keep 12 months out of the analysis for forecast accuracy checking
n_for <- 12
ts_electricity_price <- ts(
electricity_price_processed[1:(nobs-n_for),2:(nvar+1)],
start=c(year(electricity_price_processed$Month[1]),month(electricity_price_processed$Month[1])),
frequency=12)
#note that we are only transforming columns with electricity price, not the date columns
head(ts_electricity_price,15)
tail(ts_electricity_price,15)
TS_Plot <-
ggplot(electricity_price_processed, aes(x=Month, y=All.sectors)) +
geom_line()
plot(TS_Plot)
#ACF and PACF plots
par(mfrow=c(1,2))
ACF_Plot <- Acf(electricity_price_processed$All.sectors, lag = 40, plot = TRUE,main="")
PACF_Plot <- Pacf(electricity_price_processed$All.sectors, lag = 40, plot = TRUE,main="")
par(mfrow=c(1,1))
#Using R decompose function
decompose_allsectors_price <- decompose(ts_electricity_price[,"All.sectors"],"additive")
plot(decompose_allsectors_price)
#The ACF plot show a slow decay which is a sign of non-stationarity.
#Creating non-seasonal residential price time series because some models can't handle seasonality
deseasonal_allsectors_price <- seasadj(decompose_allsectors_price)
MEAN_seas <- meanf(y = ts_electricity_price[,"All.sectors"], h = 12)
checkresiduals(MEAN_seas)
SNAIVE_seas <- snaive(ts_electricity_price[,"All.sectors"], h=12)
checkresiduals(SNAIVE_seas)
SARIMA_autofit <- auto.arima(ts_electricity_price[,"All.sectors"])
checkresiduals(SARIMA_autofit)
knitr::opts_chunk$set(echo = TRUE,tidy.opts=list(width.cutoff=80), tidy=FALSE)
library(lubridate)
library(ggplot2)
library(forecast)
#library(Kendall)
library(tseries)
#library(outliers)
library(tidyverse)
library(smooth)
#New package for M9 to assist with tables
#install.packages("kableExtra")
library(kableExtra)
library(lubridate)
library(ggplot2)
library(forecast)
#library(Kendall)
library(tseries)
#library(outliers)
library(tidyverse)
library(smooth)
#New package for M9 to assist with tables
#install.packages("kableExtra")
library(kableExtra)
library(lubridate)
library(ggplot2)
library(forecast)
#library(Kendall)
library(tseries)
#library(outliers)
library(tidyverse)
library(smooth)
#New package for M9 to assist with tables
install.packages("kableExtra")
library(kableExtra)
actual=c(107,125,115,118,108)
forecast=c(110,121,112,120,109)
#Exercise 1: compute MAD, MSE and MAPE
n=length(actual)
ME =
MSE =
RMSE =
MAE =
MPE =
MAPE =
#Exercise 2: Compute the forecast accuracy metrics you calculated in Ex 1 with the results from accuracy() function.
observed <- electricity_price_processed[(nobs-n_for+1):nobs, "All.sectors"]
#Model 1: Arithmetic mean
MEAN_scores <- accuracy(MEAN_seas$mean,observed)  #store the performance metrics
plot(MEAN_seas)  #plot forecasts
#Model 2: Seasonal naive
SNAIVE_scores <- accuracy(SNAIVE_seas$mean,observed)
plot(SNAIVE_seas)
# Model 3:  SARIMA
#remember auto.arima does not call the forecast() internally so we need one more step
SARIMA_for <- forecast(SARIMA_autofit,h=12)
SARIMA_scores <- accuracy(SARIMA_for$mean,observed)
plot(SARIMA_for)
#create data frame
seas_scores <- as.data.frame(rbind(MEAN_scores, SNAIVE_scores, SARIMA_scores))
row.names(seas_scores) <- c("MEAN", "SNAIVE","SARIMA")
#choose model with lowest RMSE
best_model_index <- which.min(seas_scores[,"RMSE"])
cat("The best model by RMSE is:", row.names(seas_scores[best_model_index,]))
View(seas_scores)
mean_scores<- accuracy(forecast,actual)
View(mean_scores)
knitr::opts_chunk$set(echo = TRUE,tidy.opts=list(width.cutoff=80), tidy=FALSE)
library(lubridate)
library(ggplot2)
library(forecast)
#library(Kendall)
library(tseries)
#library(outliers)
library(tidyverse)
library(smooth)
#New package for M9 to assist with tables
#install.packages("kableExtra")
library(kableExtra)
actual=c(107,125,115,118,108)
forecast=c(110,121,112,120,109)
#Exercise 1: compute MAD, MSE and MAPE
n=length(actual)
ME = sum(actual - forecast)/n
MSE = sum((actual - forecast)^2)/n
RMSE = sqrt(MSE)
MAE = sum(abs(actual - forecast))/n
MPE = sum((actual - forecast)/actual)/n*100
MAPE = sum(abs(actual - forecast)/actual)/n*100
manual_scores <- data.frame(ME,MSE,RMSE,MAE,MPE,MAPE)
manual_scores
#Exercise 2: Compute the forecast accuracy metrics you calculated in Ex 1 with the results from accuracy() function.
auto_scores <- as.data.frame(accuracy(forecast,actual))
auto_scores
knitr::opts_chunk$set(echo = TRUE,tidy.opts=list(width.cutoff=80), tidy=FALSE)
library(lubridate)
library(ggplot2)
library(forecast)
#library(Kendall)
library(tseries)
#library(outliers)
library(tidyverse)
library(smooth)
#New package for M9 to assist with tables
#install.packages("kableExtra")
library(kableExtra)
actual=c(107,125,115,118,108)
forecast=c(110,121,112,120,109)
#Exercise 1: compute MAD, MSE and MAPE
n=length(actual)
ME = sum(actual - forecast)/n
MSE = sum((actual - forecast)^2)/n
RMSE = sqrt(MSE)
MAE = sum(abs(actual - forecast))/n
MPE = sum((actual - forecast)/actual)/n*100
MAPE = sum(abs(actual - forecast)/actual)/n*100
manual_scores <- data.frame(ME,MSE,RMSE,MAE,MPE,MAPE)
manual_scores
#Exercise 2: Compute the forecast accuracy metrics you calculated in Ex 1 with the results from accuracy() function.
auto_scores <- as.data.frame(accuracy(forecast,actual))
auto_scores
# Import both datasets using the read.csv function.
Rainfall_BR <- read.csv("./Data/pr_1901_2016_BRA.csv", stringsAsFactors = TRUE)
Temp_BR <- read.csv("./Data/tas_1901_2016_BRA.csv", stringsAsFactors = TRUE)
# Tidy the rainfall data sets.
#a Rename the column with Rainfall to get rid of the dots.
#b Note that on both data sets that is a column with the month name and average. Convert it to a Month column by separating the string, i.e., month in one column and the word "Average" on another. Hint: use the separate() function in the pipe.
#c Now you should have a column with Month. Use the paste0() function to paste month and year together and create a date object.
#d Select only the columns of interest: Date and rainfall
Rainfall_BR_processed <-
Rainfall_BR %>%
rename( Rainfall = Rainfall....MM.) %>%
separate(Statistics,c("Null","Month","Null2")," ") %>%
mutate( Date = my(paste0(Month,"-",Year))) %>%
select(Date,Rainfall)
#Repeat for the temperature dataset.
Temp_BR_processed <-
Temp_BR %>%
rename( Temperature_C = Temperature....Celsius.) %>%
separate(Statistics,c("Null","Month","Null2")," ") %>%
mutate( Date = my(paste0(Month,"-",Year))) %>%
select(Date,Temperature_C)
#Join the temperature and rainfall into one tidy data frame with 3 columns: Date, Rainfall and Temperature.
BR_complete <- inner_join(Rainfall_BR_processed,Temp_BR_processed)
f_month <- month(first(BR_complete$Date))
f_year <- year(first(BR_complete$Date))
BR_Rain_ts <- ts(BR_complete$Rainfall,frequency = 12)
BR_Temp_ts <- ts(BR_complete$Temperature_C,frequency = 12)
BR_Rain_Decomposed <- stl(BR_Rain_ts, s.window = "periodic")
plot(BR_Rain_Decomposed)
BR_Temp_Decomposed <- stl(BR_Temp_ts, s.window = "periodic")
plot(BR_Temp_Decomposed)
BR_Temp_ts_deseas <- seasadj(BR_Temp_Decomposed)
#Exercise 3: Try fitting different model to the deseasonal series. Check teh residuals using the checkresiduals() function.
# Model 1: Naive on deseas data
NAIVE_deseas <- naive(BR_Temp_ts_deseas, h=12)
checkresiduals(NAIVE_deseas)
# Model 2:  ARIMA on deseasonal data
ARIMA_autofit <- auto.arima(BR_Temp_ts_deseas, max.D = 0, max.P = 0, max.Q = 0)
checkresiduals(ARIMA_autofit)
# Model 3:  Simple exponential smoothing on deseasonal data
SES_deseas=ses(y = BR_Temp_ts_deseas, h = 12, holdout = FALSE, silent = FALSE)  #alpha is NULL
checkresiduals(SES_deseas)
#Exercise 4: Apply function accuracy() to the forecasts generated with each model you fit for the non-seasonal data on Ex 3.
#Model 1: Arithmetic mean
NAIVE_scores <- accuracy(NAIVE_deseas)  #store the performance metrics
plot(NAIVE_deseas)  #plot forecasts
# Model 2:  ARIMA
#remember auto.arima does not call the forecast() internally so we need one more step
ARIMA_forecast <- forecast(object = ARIMA_autofit, h = 12)
ARIMA_scores <- accuracy(ARIMA_forecast)
plot(ARIMA_forecast)
# Model 3:  Simple exponential smoothing on deseasonal data
SES_scores <- accuracy(SES_deseas)  #store the performance metrics
plot(SES_deseas)  #
# Exercise 5: create data frame that combines metrics for all the models you created on Ex 3.
deseas_scores <- as.data.frame(rbind(NAIVE_scores, ARIMA_scores, SES_scores))
row.names(deseas_scores) <- c("NAIVE", "ARIMA","SES")
# Exercise 6: Decide which model is the best fit by comparing the RMSE metric, i.e, choose model with lowest RMSE
best_model_index <- which.min(deseas_scores[,"RMSE"])
cat("The best model by RMSE is:", row.names(deseas_scores[best_model_index,]))
# Exercise 7: Generate a comparison table for your report using the kbl() function.
kbl(deseas_scores,
caption = "Forecast Accuracy for Non-seasonal Temperature Data",
digits = array(5,ncol(deseas_scores))) %>%
kable_styling(full_width = FALSE, position = "center") %>%
#highlight model with lowest RMSE
kable_styling(latex_options="striped", stripe_index = which.min(seas_scores[,"RMSE"]))
plot(NAIVE_deseas)  #plot forecasts
# Model 1: Naive on deseas data
NAIVE_deseas <- naive(BR_Temp_ts_deseas, h=12)
checkresiduals(NAIVE_deseas)
# Exercise 5: create data frame that combines metrics for all the models you created on Ex 3.
deseas_scores <- as.data.frame(rbind(NAIVE_scores, ARIMA_scores, SES_scores))
row.names(deseas_scores) <- c("NAIVE", "ARIMA","SES")
# Exercise 6: Decide which model is the best fit by comparing the RMSE metric, i.e, choose model with lowest RMSE
best_model_index <- which.min(deseas_scores[,"RMSE"])
cat("The best model by RMSE is:", row.names(deseas_scores[best_model_index,]))
# Exercise 7: Generate a comparison table for your report using the kbl() function.
kbl(deseas_scores,
caption = "Forecast Accuracy for Non-seasonal Temperature Data",
digits = array(5,ncol(deseas_scores))) %>%
kable_styling(full_width = FALSE, position = "center") %>%
#highlight model with lowest RMSE
kable_styling(latex_options="striped", stripe_index = which.min(seas_scores[,"RMSE"]))
